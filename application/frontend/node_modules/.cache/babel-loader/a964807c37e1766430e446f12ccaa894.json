{"ast":null,"code":"import PostgrestFilterBuilder from './PostgrestFilterBuilder';\nexport default class PostgrestQueryBuilder {\n  constructor(url, _ref) {\n    let {\n      headers = {},\n      schema,\n      fetch\n    } = _ref;\n    this.url = url;\n    this.headers = headers;\n    this.schema = schema;\n    this.fetch = fetch;\n  }\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n\n\n  select(columns) {\n    let {\n      head = false,\n      count\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const method = head ? 'HEAD' : 'GET'; // Remove whitespaces except when quoted\n\n    let quoted = false;\n    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(c => {\n      if (/\\s/.test(c) && !quoted) {\n        return '';\n      }\n\n      if (c === '\"') {\n        quoted = !quoted;\n      }\n\n      return c;\n    }).join('');\n    this.url.searchParams.set('select', cleanedColumns);\n\n    if (count) {\n      this.headers['Prefer'] = `count=${count}`;\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n\n\n  insert(values) {\n    let {\n      count\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const method = 'POST';\n    const prefersHeaders = [];\n    const body = values;\n\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer']);\n    }\n\n    this.headers['Prefer'] = prefersHeaders.join(',');\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map(column => `\"${column}\"`);\n        this.url.searchParams.set('columns', uniqueColumns.join(','));\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  /**\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n   * exist, or if it does exist, perform an alternative action depending on\n   * `ignoreDuplicates`.\n   *\n   * By default, upserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to upsert with. Pass an object to upsert a\n   * single row or an array to upsert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n   * duplicate rows are determined. Two rows are duplicates if all the\n   * `onConflict` columns are equal.\n   *\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n   * `false`, duplicate rows are merged with existing rows.\n   *\n   * @param options.count - Count algorithm to use to count upserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n\n\n  upsert(values) {\n    let {\n      onConflict,\n      ignoreDuplicates = false,\n      count\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const method = 'POST';\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`];\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);\n    const body = values;\n\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer']);\n    }\n\n    this.headers['Prefer'] = prefersHeaders.join(',');\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n\n\n  update(values) {\n    let {\n      count\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const method = 'PATCH';\n    const prefersHeaders = [];\n    const body = values;\n\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer']);\n    }\n\n    this.headers['Prefer'] = prefersHeaders.join(',');\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n\n\n  delete() {\n    let {\n      count\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const method = 'DELETE';\n    const prefersHeaders = [];\n\n    if (count) {\n      prefersHeaders.push(`count=${count}`);\n    }\n\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer']);\n    }\n\n    this.headers['Prefer'] = prefersHeaders.join(',');\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["PostgrestFilterBuilder","PostgrestQueryBuilder","constructor","url","headers","schema","fetch","select","columns","head","count","method","quoted","cleanedColumns","split","map","c","test","join","searchParams","set","allowEmpty","insert","values","prefersHeaders","body","push","unshift","Array","isArray","reduce","acc","x","concat","Object","keys","length","uniqueColumns","Set","column","upsert","onConflict","ignoreDuplicates","undefined","update","delete"],"sources":["D:\\Documenti\\GitHub\\ZooGames\\application\\frontend\\node_modules\\@supabase\\postgrest-js\\src\\PostgrestQueryBuilder.ts"],"sourcesContent":["import PostgrestBuilder from './PostgrestBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser'\nimport { Fetch, GenericSchema, GenericTable, GenericView } from './types'\n\nexport default class PostgrestQueryBuilder<\n  Schema extends GenericSchema,\n  Relation extends GenericTable | GenericView\n> {\n  url: URL\n  headers: Record<string, string>\n  schema?: string\n  signal?: AbortSignal\n  fetch?: Fetch\n\n  constructor(\n    url: URL,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: Record<string, string>\n      schema?: string\n      fetch?: Fetch\n    }\n  ) {\n    this.url = url\n    this.headers = headers\n    this.schema = schema\n    this.fetch = fetch\n  }\n\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  select<Query extends string = '*', Result = GetResult<Schema, Relation['Row'], Query>>(\n    columns?: Query,\n    {\n      head = false,\n      count,\n    }: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], Result> {\n    const method = head ? 'HEAD' : 'GET'\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    if (count) {\n      this.headers['Prefer'] = `count=${count}`\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<Result>)\n  }\n\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      count,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], undefined> {\n    const method = 'POST'\n\n    const prefersHeaders = []\n    const body = values\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<undefined>)\n  }\n\n  /**\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n   * exist, or if it does exist, perform an alternative action depending on\n   * `ignoreDuplicates`.\n   *\n   * By default, upserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to upsert with. Pass an object to upsert a\n   * single row or an array to upsert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n   * duplicate rows are determined. Two rows are duplicates if all the\n   * `onConflict` columns are equal.\n   *\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n   * `false`, duplicate rows are merged with existing rows.\n   *\n   * @param options.count - Count algorithm to use to count upserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      onConflict,\n      ignoreDuplicates = false,\n      count,\n    }: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], undefined> {\n    const method = 'POST'\n\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`]\n\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\n    const body = values\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<undefined>)\n  }\n\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  update<Row extends Relation extends { Update: unknown } ? Relation['Update'] : never>(\n    values: Row,\n    {\n      count,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], undefined> {\n    const method = 'PATCH'\n    const prefersHeaders = []\n    const body = values\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<undefined>)\n  }\n\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  delete({\n    count,\n  }: {\n    count?: 'exact' | 'planned' | 'estimated'\n  } = {}): PostgrestFilterBuilder<Schema, Relation['Row'], undefined> {\n    const method = 'DELETE'\n    const prefersHeaders = []\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<undefined>)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}