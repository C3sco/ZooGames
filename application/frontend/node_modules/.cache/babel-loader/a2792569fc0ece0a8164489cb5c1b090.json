{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, NETWORK_FAILURE, STORAGE_KEY } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthUnknownError, isAuthApiError, isAuthError } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch';\nimport { decodeJWTPayload, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS\n};\nexport default class GoTrueClient {\n  /**\n   * Create a new client for use in the browser.\n   */\n  constructor(options) {\n    this.stateChangeEmitters = new Map();\n    this.networkRetries = 0;\n    this.refreshingDeferred = null;\n    /**\n     * Keeps track of the async client initialization.\n     * When null or not yet resolved the auth state is `unknown`\n     * Once resolved the the auth state is known and it's save to call any further client methods.\n     * Keep extra care to never reject or throw uncaught errors\n     */\n\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || localStorageAdapter;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.initialize();\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n    };\n  }\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n\n\n  initialize() {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize();\n    }\n\n    return this.initializePromise;\n  }\n  /**\n   * IMPORTANT:\n   * 1. Never throw in this method, as it is called from the constructor\n   * 2. Never return a session from this method as it would be cached over\n   *    the whole lifetime of the client\n   */\n\n\n  _initialize() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.initializePromise) {\n        return this.initializePromise;\n      }\n\n      try {\n        if (this.detectSessionInUrl && this._isImplicitGrantFlow()) {\n          const {\n            data,\n            error\n          } = yield this._getSessionFromUrl();\n\n          if (error) {\n            // failed login attempt via url,\n            // remove old session as in verifyOtp, signUp and signInWith*\n            yield this._removeSession();\n            return {\n              error\n            };\n          }\n\n          const {\n            session,\n            redirectType\n          } = data;\n          yield this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN', session);\n\n          if (redirectType === 'recovery') {\n            this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n          }\n\n          return {\n            error: null\n          };\n        } // no login attempt via callback url try to recover session from storage\n\n\n        yield this._recoverAndRefresh();\n        return {\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            error\n          };\n        }\n\n        return {\n          error: new AuthUnknownError('Unexpected error during initialization', error)\n        };\n      } finally {\n        this._handleVisibilityChange();\n      }\n    });\n  }\n  /**\n   * Creates a new user.\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n\n\n  signUp(credentials) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n\n        if ('email' in credentials) {\n          const {\n            email,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n            headers: this.headers,\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n            body: {\n              email,\n              password,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else if ('phone' in credentials) {\n          const {\n            phone,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n        }\n\n        const {\n          data,\n          error\n        } = res;\n\n        if (error || !data) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: error\n          };\n        }\n\n        const session = data.session;\n        const user = data.user;\n\n        if (data.session) {\n          yield this._saveSession(data.session);\n\n          this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n\n        return {\n          data: {\n            user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in an existing user with an email and password or phone and password.\n   */\n\n\n  signInWithPassword(credentials) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n\n        if ('email' in credentials) {\n          const {\n            email,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              email,\n              password,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else if ('phone' in credentials) {\n          const {\n            phone,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n        }\n\n        const {\n          data,\n          error\n        } = res;\n        if (error || !data) return {\n          data: {\n            user: null,\n            session: null\n          },\n          error\n        };\n\n        if (data.session) {\n          yield this._saveSession(data.session);\n\n          this._notifyAllSubscribers('SIGNED_IN', data.session);\n        }\n\n        return {\n          data,\n          error\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in an existing user via a third-party provider.\n   */\n\n\n  signInWithOAuth(credentials) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._removeSession();\n      return this._handleProviderSignIn(credentials.provider, {\n        redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n        scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n        queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams\n      });\n    });\n  }\n  /**\n   * Log in a user using magiclink or a one-time password (OTP).\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n   */\n\n\n  signInWithOtp(credentials) {\n    var _a, _b, _c, _d;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n\n        if ('email' in credentials) {\n          const {\n            email,\n            options\n          } = credentials;\n          const {\n            error\n          } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              email,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n          });\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        if ('phone' in credentials) {\n          const {\n            phone,\n            options\n          } = credentials;\n          const {\n            error\n          } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              phone,\n              data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n              create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            }\n          });\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   */\n\n\n  verifyOtp(params) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/verify`, {\n          headers: this.headers,\n          body: Object.assign(Object.assign({}, params), {\n            gotrue_meta_security: {\n              captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken\n            }\n          }),\n          redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n          xform: _sessionResponse\n        });\n\n        if (error) {\n          throw error;\n        }\n\n        if (!data) {\n          throw 'An error occurred on token verification.';\n        }\n\n        const session = data.session;\n        const user = data.user;\n\n        if (session === null || session === void 0 ? void 0 : session.access_token) {\n          yield this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n\n        return {\n          data: {\n            user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Attempts a single-sign on using an enterprise Identity Provider. A\n   * successful SSO attempt will redirect the current page to the identity\n   * provider authorization page. The redirect URL is implementation and SSO\n   * protocol specific.\n   *\n   * You can use it by providing a SSO domain. Typically you can extract this\n   * domain by asking users for their email address. If this domain is\n   * registered on the Auth instance the redirect will use that organization's\n   * currently active SSO Identity Provider for the login.\n   *\n   * If you have built an organization-specific login page, you can use the\n   * organization's SSO Identity Provider UUID directly instead.\n   *\n   * This API is experimental and availability is conditional on correct\n   * settings on the Auth service.\n   *\n   * @experimental\n   */\n\n\n  signInWithSSO(params) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        return yield _request(this.fetch, 'POST', `${this.url}/sso`, {\n          body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {\n            provider_id: params.providerId\n          } : null), 'domain' in params ? {\n            domain: params.domain\n          } : null), {\n            redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n          }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n            gotrue_meta_security: {\n              captcha_token: params.options.captchaToken\n            }\n          } : null), {\n            skip_http_redirect: true\n          }),\n          headers: this.headers,\n          xform: _ssoResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Returns the session, refreshing it if necessary.\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n   */\n\n\n  getSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // make sure we've read the session from the url if there is one\n      // save to just await, as long we make sure _initialize() never throws\n      yield this.initializePromise;\n      let currentSession = null;\n\n      if (this.persistSession) {\n        const maybeSession = yield getItemAsync(this.storage, this.storageKey);\n\n        if (maybeSession !== null) {\n          if (this._isValidSession(maybeSession)) {\n            currentSession = maybeSession;\n          } else {\n            yield this._removeSession();\n          }\n        }\n      } else {\n        currentSession = this.inMemorySession;\n      }\n\n      if (!currentSession) {\n        return {\n          data: {\n            session: null\n          },\n          error: null\n        };\n      }\n\n      const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;\n\n      if (!hasExpired) {\n        return {\n          data: {\n            session: currentSession\n          },\n          error: null\n        };\n      }\n\n      const {\n        session,\n        error\n      } = yield this._callRefreshToken(currentSession.refresh_token);\n\n      if (error) {\n        return {\n          data: {\n            session: null\n          },\n          error\n        };\n      }\n\n      return {\n        data: {\n          session\n        },\n        error: null\n      };\n    });\n  }\n  /**\n   * Gets the current user details if there is an existing session.\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n   */\n\n\n  getUser(jwt) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!jwt) {\n          const {\n            data,\n            error\n          } = yield this.getSession();\n\n          if (error) {\n            throw error;\n          } // Default to Authorization header if there is no existing session\n\n\n          jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n        }\n\n        return yield _request(this.fetch, 'GET', `${this.url}/user`, {\n          headers: this.headers,\n          jwt: jwt,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n\n\n  updateUser(attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          throw sessionError;\n        }\n\n        if (!sessionData.session) {\n          throw new AuthSessionMissingError();\n        }\n\n        const session = sessionData.session;\n        const {\n          data,\n          error: userError\n        } = yield _request(this.fetch, 'PUT', `${this.url}/user`, {\n          headers: this.headers,\n          body: attributes,\n          jwt: session.access_token,\n          xform: _userResponse\n        });\n        if (userError) throw userError;\n        session.user = data.user;\n        yield this._saveSession(session);\n\n        this._notifyAllSubscribers('USER_UPDATED', session);\n\n        return {\n          data: {\n            user: session.user\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Decodes a JWT (without performing any validation).\n   */\n\n\n  _decodeJWT(jwt) {\n    return decodeJWTPayload(jwt);\n  }\n  /**\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\n   * @param currentSession The current session that minimally contains an access token and refresh token.\n   */\n\n\n  setSession(currentSession) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!currentSession.access_token || !currentSession.refresh_token) {\n          throw new AuthSessionMissingError();\n        }\n\n        const timeNow = Date.now() / 1000;\n        let expiresAt = timeNow;\n        let hasExpired = true;\n        let session = null;\n        const payload = decodeJWTPayload(currentSession.access_token);\n\n        if (payload.exp) {\n          expiresAt = payload.exp;\n          hasExpired = expiresAt <= timeNow;\n        }\n\n        if (hasExpired) {\n          const {\n            session: refreshedSession,\n            error\n          } = yield this._callRefreshToken(currentSession.refresh_token);\n\n          if (error) {\n            return {\n              data: {\n                user: null,\n                session: null\n              },\n              error: error\n            };\n          }\n\n          if (!refreshedSession) {\n            return {\n              data: {\n                user: null,\n                session: null\n              },\n              error: null\n            };\n          }\n\n          session = refreshedSession;\n        } else {\n          const {\n            data,\n            error\n          } = yield this.getUser(currentSession.access_token);\n\n          if (error) {\n            throw error;\n          }\n\n          session = {\n            access_token: currentSession.access_token,\n            refresh_token: currentSession.refresh_token,\n            user: data.user,\n            token_type: 'bearer',\n            expires_in: expiresAt - timeNow,\n            expires_at: expiresAt\n          };\n          yield this._saveSession(session);\n        }\n\n        return {\n          data: {\n            user: session.user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Returns a new session, regardless of expiry status.\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n   * If the current session's refresh token is invalid, an error will be thrown.\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\n   */\n\n\n  refreshSession(currentSession) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!currentSession) {\n          const {\n            data,\n            error\n          } = yield this.getSession();\n\n          if (error) {\n            throw error;\n          }\n\n          currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n        }\n\n        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n          throw new AuthSessionMissingError();\n        }\n\n        const {\n          session,\n          error\n        } = yield this._callRefreshToken(currentSession.refresh_token);\n\n        if (error) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: error\n          };\n        }\n\n        if (!session) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: null\n          };\n        }\n\n        return {\n          data: {\n            user: session.user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Gets the session data from a URL string\n   */\n\n\n  _getSessionFromUrl() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.');\n\n        if (!this._isImplicitGrantFlow()) {\n          throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n        }\n\n        const error_description = getParameterByName('error_description');\n\n        if (error_description) {\n          const error_code = getParameterByName('error_code');\n          if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.');\n          const error = getParameterByName('error');\n          if (!error) throw new AuthImplicitGrantRedirectError('No error detected.');\n          throw new AuthImplicitGrantRedirectError(error_description, {\n            error,\n            code: error_code\n          });\n        }\n\n        const provider_token = getParameterByName('provider_token');\n        const provider_refresh_token = getParameterByName('provider_refresh_token');\n        const access_token = getParameterByName('access_token');\n        if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.');\n        const expires_in = getParameterByName('expires_in');\n        if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n        const refresh_token = getParameterByName('refresh_token');\n        if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n        const token_type = getParameterByName('token_type');\n        if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.');\n        const timeNow = Math.round(Date.now() / 1000);\n        const expires_at = timeNow + parseInt(expires_in);\n        const {\n          data,\n          error\n        } = yield this.getUser(access_token);\n        if (error) throw error;\n        const user = data.user;\n        const session = {\n          provider_token,\n          provider_refresh_token,\n          access_token,\n          expires_in: parseInt(expires_in),\n          expires_at,\n          refresh_token,\n          token_type,\n          user\n        };\n        const redirectType = getParameterByName('type'); // Remove tokens from URL\n\n        window.location.hash = '';\n        return {\n          data: {\n            session,\n            redirectType\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              redirectType: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n   */\n\n\n  _isImplicitGrantFlow() {\n    return isBrowser() && (Boolean(getParameterByName('access_token')) || Boolean(getParameterByName('error_description')));\n  }\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n   */\n\n\n  signOut() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data,\n        error: sessionError\n      } = yield this.getSession();\n\n      if (sessionError) {\n        return {\n          error: sessionError\n        };\n      }\n\n      const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n\n      if (accessToken) {\n        const {\n          error\n        } = yield this.admin.signOut(accessToken);\n\n        if (error) {\n          // ignore 404s since user might not exist anymore\n          // ignore 401s since an invalid or expired JWT should sign out the current session\n          if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\n            return {\n              error\n            };\n          }\n        }\n      }\n\n      yield this._removeSession();\n\n      this._notifyAllSubscribers('SIGNED_OUT', null);\n\n      return {\n        error: null\n      };\n    });\n  }\n  /**\n   * Receive a notification every time an auth event happens.\n   * @param callback A callback function to be invoked when an auth event happens.\n   */\n\n\n  onAuthStateChange(callback) {\n    const id = uuid();\n    const subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id);\n      }\n    };\n    this.stateChangeEmitters.set(id, subscription);\n    return {\n      data: {\n        subscription\n      }\n    };\n  }\n  /**\n   * Sends a password reset request to an email address.\n   * @param email The email address of the user.\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n   */\n\n\n  resetPasswordForEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, 'POST', `${this.url}/recover`, {\n          body: {\n            email,\n            gotrue_meta_security: {\n              captcha_token: options.captchaToken\n            }\n          },\n          headers: this.headers,\n          redirectTo: options.redirectTo\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n\n\n  _refreshAccessToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n          body: {\n            refresh_token: refreshToken\n          },\n          headers: this.headers,\n          xform: _sessionResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n\n  _isValidSession(maybeSession) {\n    const isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;\n    return isValidSession;\n  }\n\n  _handleProviderSignIn(provider) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const url = this._getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams\n    }); // try to open on the browser\n\n\n    if (isBrowser()) {\n      window.location.href = url;\n    }\n\n    return {\n      data: {\n        provider,\n        url\n      },\n      error: null\n    };\n  }\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n\n\n  _recoverAndRefresh() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const currentSession = yield getItemAsync(this.storage, this.storageKey);\n\n        if (!this._isValidSession(currentSession)) {\n          if (currentSession !== null) {\n            yield this._removeSession();\n          }\n\n          return;\n        }\n\n        const timeNow = Math.round(Date.now() / 1000);\n\n        if (((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN) {\n          if (this.autoRefreshToken && currentSession.refresh_token) {\n            this.networkRetries++;\n            const {\n              error\n            } = yield this._callRefreshToken(currentSession.refresh_token);\n\n            if (error) {\n              console.log(error.message);\n\n              if (error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) {\n                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                this.refreshTokenTimer = setTimeout(() => this._recoverAndRefresh(), Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                );\n                return;\n              }\n\n              yield this._removeSession();\n            }\n\n            this.networkRetries = 0;\n          } else {\n            yield this._removeSession();\n          }\n        } else {\n          if (this.persistSession) {\n            yield this._saveSession(currentSession);\n          }\n\n          this._notifyAllSubscribers('SIGNED_IN', currentSession);\n        }\n      } catch (err) {\n        console.error(err);\n        return;\n      }\n    });\n  }\n\n  _callRefreshToken(refreshToken) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      // refreshing is already in progress\n      if (this.refreshingDeferred) {\n        return this.refreshingDeferred.promise;\n      }\n\n      try {\n        this.refreshingDeferred = new Deferred();\n\n        if (!refreshToken) {\n          throw new AuthSessionMissingError();\n        }\n\n        const {\n          data,\n          error\n        } = yield this._refreshAccessToken(refreshToken);\n        if (error) throw error;\n        if (!data.session) throw new AuthSessionMissingError();\n        yield this._saveSession(data.session);\n\n        this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n\n        const result = {\n          session: data.session,\n          error: null\n        };\n        this.refreshingDeferred.resolve(result);\n        return result;\n      } catch (error) {\n        if (isAuthError(error)) {\n          const result = {\n            session: null,\n            error\n          };\n          (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n          return result;\n        }\n\n        (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n        throw error;\n      } finally {\n        this.refreshingDeferred = null;\n      }\n    });\n  }\n\n  _notifyAllSubscribers(event, session) {\n    this.stateChangeEmitters.forEach(x => x.callback(event, session));\n  }\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n\n\n  _saveSession(session) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.persistSession) {\n        this.inMemorySession = session;\n      }\n\n      const expiresAt = session.expires_at;\n\n      if (expiresAt) {\n        const timeNow = Math.round(Date.now() / 1000);\n        const expiresIn = expiresAt - timeNow;\n        const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n\n        this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n      }\n\n      if (this.persistSession && session.expires_at) {\n        yield this._persistSession(session);\n      }\n    });\n  }\n\n  _persistSession(currentSession) {\n    return setItemAsync(this.storage, this.storageKey, currentSession);\n  }\n\n  _removeSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.persistSession) {\n        yield removeItemAsync(this.storage, this.storageKey);\n      } else {\n        this.inMemorySession = null;\n      }\n\n      if (this.refreshTokenTimer) {\n        clearTimeout(this.refreshTokenTimer);\n      }\n    });\n  }\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds.\n   * @param session The current session.\n   */\n\n\n  _startAutoRefreshToken(value) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n    if (value <= 0 || !this.autoRefreshToken) return;\n    this.refreshTokenTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n      this.networkRetries++;\n      const {\n        data: {\n          session\n        },\n        error: sessionError\n      } = yield this.getSession();\n\n      if (!sessionError && session) {\n        const {\n          error\n        } = yield this._callRefreshToken(session.refresh_token);\n        if (!error) this.networkRetries = 0;\n        if (error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n      }\n    }), value);\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n  }\n\n  _handleVisibilityChange() {\n    if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      return false;\n    }\n\n    try {\n      window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', () => __awaiter(this, void 0, void 0, function* () {\n        if (document.visibilityState === 'visible') {\n          yield this.initializePromise;\n          yield this._recoverAndRefresh();\n        }\n      }));\n    } catch (error) {\n      console.error('_handleVisibilityChange', error);\n    }\n  }\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n   */\n\n\n  _getUrlForProvider(provider, options) {\n    const urlParams = [`provider=${encodeURIComponent(provider)}`];\n\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.queryParams) {\n      const query = new URLSearchParams(options.queryParams);\n      urlParams.push(query.toString());\n    }\n\n    return `${this.url}/authorize?${urlParams.join('&')}`;\n  }\n\n  _unenroll(params) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n\n        return yield _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Enrolls a factor\n   * @param friendlyName Human readable name assigned to a device\n   * @param factorType device which we're validating against. Can only be TOTP for now.\n   * @param issuer domain which the user is enrolling with\n   */\n\n\n  _enroll(params) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/factors`, {\n          body: {\n            friendly_name: params.friendlyName,\n            factor_type: params.factorType,\n            issuer: params.issuer\n          },\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n\n        if (error) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n        }\n\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Validates a device as part of the enrollment step.\n   * @param factorId System assigned identifier for authenticator device as returned by enroll\n   * @param code Code Generated by an authenticator device\n   */\n\n\n  _verify(params) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/verify`, {\n          body: {\n            code: params.code,\n            challenge_id: params.challengeId\n          },\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n\n        if (error) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        yield this._saveSession(Object.assign({\n          expires_at: Math.round(Date.now() / 1000) + data.expires_in\n        }, data));\n\n        this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n\n        return {\n          data,\n          error\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Creates a challenge which a user can verify against\n   * @param factorId System assigned identifier for authenticator device as returned by enroll\n   */\n\n\n  _challenge(params) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n\n        return yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/challenge`, {\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Creates a challenge and immediately verifies it\n   * @param factorId System assigned identifier for authenticator device as returned by enroll\n   * @param code Code Generated by an authenticator device\n   */\n\n\n  _challengeAndVerify(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: challengeData,\n        error: challengeError\n      } = yield this._challenge({\n        factorId: params.factorId\n      });\n\n      if (challengeError) {\n        return {\n          data: null,\n          error: challengeError\n        };\n      }\n\n      return yield this._verify({\n        factorId: params.factorId,\n        challengeId: challengeData.id,\n        code: params.code\n      });\n    });\n  }\n  /**\n   * Displays all devices for a given user\n   */\n\n\n  _listFactors() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: {\n          user\n        },\n        error: userError\n      } = yield this.getUser();\n\n      if (userError) {\n        return {\n          data: null,\n          error: userError\n        };\n      }\n\n      const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n      const totp = factors.filter(factor => factor.factor_type === 'totp' && factor.status === 'verified');\n      return {\n        data: {\n          all: factors,\n          totp\n        },\n        error: null\n      };\n    });\n  }\n  /**\n   * Gets the current and next authenticator assurance level (AAL)\n   * and the current authentication methods for the session (AMR)\n   */\n\n\n  _getAuthenticatorAssuranceLevel() {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: {\n          session\n        },\n        error: sessionError\n      } = yield this.getSession();\n\n      if (sessionError) {\n        return {\n          data: null,\n          error: sessionError\n        };\n      }\n\n      if (!session) {\n        return {\n          data: {\n            currentLevel: null,\n            nextLevel: null,\n            currentAuthenticationMethods: []\n          },\n          error: null\n        };\n      }\n\n      const payload = this._decodeJWT(session.access_token);\n\n      let currentLevel = null;\n\n      if (payload.aal) {\n        currentLevel = payload.aal;\n      }\n\n      let nextLevel = currentLevel;\n      const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(factor => factor.status === 'verified')) !== null && _b !== void 0 ? _b : [];\n\n      if (verifiedFactors.length > 0) {\n        nextLevel = 'aal2';\n      }\n\n      const currentAuthenticationMethods = payload.amr || [];\n      return {\n        data: {\n          currentLevel,\n          nextLevel,\n          currentAuthenticationMethods\n        },\n        error: null\n      };\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["GoTrueAdminApi","DEFAULT_HEADERS","EXPIRY_MARGIN","GOTRUE_URL","NETWORK_FAILURE","STORAGE_KEY","AuthImplicitGrantRedirectError","AuthInvalidCredentialsError","AuthRetryableFetchError","AuthSessionMissingError","AuthUnknownError","isAuthApiError","isAuthError","_request","_sessionResponse","_userResponse","_ssoResponse","decodeJWTPayload","Deferred","getItemAsync","getParameterByName","isBrowser","removeItemAsync","resolveFetch","setItemAsync","uuid","localStorageAdapter","polyfillGlobalThis","DEFAULT_OPTIONS","url","storageKey","autoRefreshToken","persistSession","detectSessionInUrl","headers","GoTrueClient","constructor","options","Map","settings","inMemorySession","storage","admin","fetch","initialize","mfa","verify","_verify","bind","enroll","_enroll","unenroll","_unenroll","challenge","_challenge","listFactors","_listFactors","challengeAndVerify","_challengeAndVerify","getAuthenticatorAssuranceLevel","_getAuthenticatorAssuranceLevel","initializePromise","_initialize","_isImplicitGrantFlow","data","error","_getSessionFromUrl","_removeSession","session","redirectType","_saveSession","_notifyAllSubscribers","_recoverAndRefresh","_handleVisibilityChange","signUp","credentials","res","email","password","redirectTo","emailRedirectTo","body","_a","gotrue_meta_security","captcha_token","captchaToken","xform","phone","_b","user","signInWithPassword","signInWithOAuth","_handleProviderSignIn","provider","scopes","queryParams","_c","signInWithOtp","create_user","shouldCreateUser","_d","verifyOtp","params","access_token","signInWithSSO","provider_id","providerId","domain","redirect_to","undefined","skip_http_redirect","getSession","currentSession","maybeSession","_isValidSession","hasExpired","expires_at","Date","now","_callRefreshToken","refresh_token","getUser","jwt","updateUser","attributes","sessionData","sessionError","userError","_decodeJWT","setSession","timeNow","expiresAt","payload","exp","refreshedSession","token_type","expires_in","refreshSession","error_description","error_code","code","provider_token","provider_refresh_token","Math","round","parseInt","window","location","hash","Boolean","signOut","accessToken","status","onAuthStateChange","callback","id","subscription","unsubscribe","stateChangeEmitters","delete","set","resetPasswordForEmail","_refreshAccessToken","refreshToken","isValidSession","_getUrlForProvider","href","Infinity","networkRetries","console","log","message","MAX_RETRIES","refreshTokenTimer","clearTimeout","setTimeout","RETRY_INTERVAL","err","refreshingDeferred","promise","result","resolve","reject","event","forEach","x","expiresIn","refreshDurationBeforeExpires","_startAutoRefreshToken","_persistSession","value","__awaiter","unref","addEventListener","document","visibilityState","urlParams","encodeURIComponent","push","query","URLSearchParams","toString","join","factorId","friendly_name","friendlyName","factor_type","factorType","issuer","totp","qr_code","challenge_id","challengeId","Object","challengeData","challengeError","factors","filter","factor","all","currentLevel","nextLevel","currentAuthenticationMethods","aal","verifiedFactors","length","amr"],"sources":["D:\\Documenti\\GitHub\\ZooGames\\application\\frontend\\node_modules\\@supabase\\gotrue-js\\src\\GoTrueClient.ts"],"sourcesContent":["import GoTrueAdminApi from './GoTrueAdminApi'\nimport {\n  DEFAULT_HEADERS,\n  EXPIRY_MARGIN,\n  GOTRUE_URL,\n  NETWORK_FAILURE,\n  STORAGE_KEY,\n} from './lib/constants'\nimport {\n  AuthError,\n  AuthImplicitGrantRedirectError,\n  AuthInvalidCredentialsError,\n  AuthRetryableFetchError,\n  AuthSessionMissingError,\n  AuthUnknownError,\n  isAuthApiError,\n  isAuthError,\n} from './lib/errors'\nimport { Fetch, _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch'\nimport {\n  decodeJWTPayload,\n  Deferred,\n  getItemAsync,\n  getParameterByName,\n  isBrowser,\n  removeItemAsync,\n  resolveFetch,\n  setItemAsync,\n  uuid,\n} from './lib/helpers'\nimport localStorageAdapter from './lib/local-storage'\nimport { polyfillGlobalThis } from './lib/polyfills'\nimport type {\n  AuthChangeEvent,\n  AuthResponse,\n  CallRefreshTokenResult,\n  GoTrueClientOptions,\n  InitializeResult,\n  OAuthResponse,\n  SSOResponse,\n  Provider,\n  Session,\n  SignInWithOAuthCredentials,\n  SignInWithPasswordCredentials,\n  SignInWithPasswordlessCredentials,\n  SignInWithSSO,\n  SignUpWithPasswordCredentials,\n  Subscription,\n  SupportedStorage,\n  User,\n  UserAttributes,\n  UserResponse,\n  VerifyOtpParams,\n  GoTrueMFAApi,\n  MFAEnrollParams,\n  AuthMFAEnrollResponse,\n  MFAChallengeParams,\n  AuthMFAChallengeResponse,\n  MFAUnenrollParams,\n  AuthMFAUnenrollResponse,\n  MFAVerifyParams,\n  AuthMFAVerifyResponse,\n  AuthMFAListFactorsResponse,\n  AMREntry,\n  AuthMFAGetAuthenticatorAssuranceLevelResponse,\n  AuthenticatorAssuranceLevels,\n  Factor,\n  MFAChallengeAndVerifyParams,\n} from './lib/types'\n\npolyfillGlobalThis() // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS: Omit<Required<GoTrueClientOptions>, 'fetch' | 'storage'> = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS,\n}\n\nexport default class GoTrueClient {\n  /**\n   * Namespace for the GoTrue admin methods.\n   * These methods should only be used in a trusted server-side environment.\n   */\n  admin: GoTrueAdminApi\n  /**\n   * Namespace for the MFA methods.\n   */\n  mfa: GoTrueMFAApi\n  /**\n   * The storage key used to identify the values saved in localStorage\n   */\n  protected storageKey: string\n\n  /**\n   * The session object for the currently logged in user. If null, it means there isn't a logged-in user.\n   * Only used if persistSession is false.\n   */\n  protected inMemorySession: Session | null\n\n  protected autoRefreshToken: boolean\n  protected persistSession: boolean\n  protected storage: SupportedStorage\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\n  protected refreshTokenTimer?: ReturnType<typeof setTimeout>\n  protected networkRetries = 0\n  protected refreshingDeferred: Deferred<CallRefreshTokenResult> | null = null\n  /**\n   * Keeps track of the async client initialization.\n   * When null or not yet resolved the auth state is `unknown`\n   * Once resolved the the auth state is known and it's save to call any further client methods.\n   * Keep extra care to never reject or throw uncaught errors\n   */\n  protected initializePromise: Promise<InitializeResult> | null = null\n  protected detectSessionInUrl = true\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected fetch: Fetch\n\n  /**\n   * Create a new client for use in the browser.\n   */\n  constructor(options: GoTrueClientOptions) {\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n    this.inMemorySession = null\n    this.storageKey = settings.storageKey\n    this.autoRefreshToken = settings.autoRefreshToken\n    this.persistSession = settings.persistSession\n    this.storage = settings.storage || localStorageAdapter\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch,\n    })\n\n    this.url = settings.url\n    this.headers = settings.headers\n    this.fetch = resolveFetch(settings.fetch)\n    this.detectSessionInUrl = settings.detectSessionInUrl\n\n    this.initialize()\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n    }\n  }\n\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n  initialize(): Promise<InitializeResult> {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize()\n    }\n\n    return this.initializePromise\n  }\n\n  /**\n   * IMPORTANT:\n   * 1. Never throw in this method, as it is called from the constructor\n   * 2. Never return a session from this method as it would be cached over\n   *    the whole lifetime of the client\n   */\n  private async _initialize(): Promise<InitializeResult> {\n    if (this.initializePromise) {\n      return this.initializePromise\n    }\n\n    try {\n      if (this.detectSessionInUrl && this._isImplicitGrantFlow()) {\n        const { data, error } = await this._getSessionFromUrl()\n\n        if (error) {\n          // failed login attempt via url,\n          // remove old session as in verifyOtp, signUp and signInWith*\n          await this._removeSession()\n\n          return { error }\n        }\n\n        const { session, redirectType } = data\n\n        await this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n        if (redirectType === 'recovery') {\n          this._notifyAllSubscribers('PASSWORD_RECOVERY', session)\n        }\n\n        return { error: null }\n      }\n\n      // no login attempt via callback url try to recover session from storage\n      await this._recoverAndRefresh()\n      return { error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { error }\n      }\n\n      return {\n        error: new AuthUnknownError('Unexpected error during initialization', error),\n      }\n    } finally {\n      this._handleVisibilityChange()\n    }\n  }\n\n  /**\n   * Creates a new user.\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  async signUp(credentials: SignUpWithPasswordCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          redirectTo: options?.emailRedirectTo,\n          body: {\n            email,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n\n      const { data, error } = res\n\n      if (error || !data) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      const session: Session | null = data.session\n      const user: User | null = data.user\n\n      if (data.session) {\n        await this._saveSession(data.session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user with an email and password or phone and password.\n   */\n  async signInWithPassword(credentials: SignInWithPasswordCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            email,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n      const { data, error } = res\n      if (error || !data) return { data: { user: null, session: null }, error }\n      if (data.session) {\n        await this._saveSession(data.session)\n        this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user via a third-party provider.\n   */\n  async signInWithOAuth(credentials: SignInWithOAuthCredentials): Promise<OAuthResponse> {\n    await this._removeSession()\n    return this._handleProviderSignIn(credentials.provider, {\n      redirectTo: credentials.options?.redirectTo,\n      scopes: credentials.options?.scopes,\n      queryParams: credentials.options?.queryParams,\n    })\n  }\n\n  /**\n   * Log in a user using magiclink or a one-time password (OTP).\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n   */\n  async signInWithOtp(credentials: SignInWithPasswordlessCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      if ('email' in credentials) {\n        const { email, options } = credentials\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            email,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          redirectTo: options?.emailRedirectTo,\n        })\n        return { data: { user: null, session: null }, error }\n      }\n      if ('phone' in credentials) {\n        const { phone, options } = credentials\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            phone,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n        })\n        return { data: { user: null, session: null }, error }\n      }\n      throw new AuthInvalidCredentialsError('You must provide either an email or phone number.')\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   */\n  async verifyOtp(params: VerifyOtpParams): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/verify`, {\n        headers: this.headers,\n        body: {\n          ...params,\n          gotrue_meta_security: { captcha_token: params.options?.captchaToken },\n        },\n        redirectTo: params.options?.redirectTo,\n        xform: _sessionResponse,\n      })\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw 'An error occurred on token verification.'\n      }\n\n      const session: Session | null = data.session\n      const user: User = data.user\n\n      if (session?.access_token) {\n        await this._saveSession(session as Session)\n        this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Attempts a single-sign on using an enterprise Identity Provider. A\n   * successful SSO attempt will redirect the current page to the identity\n   * provider authorization page. The redirect URL is implementation and SSO\n   * protocol specific.\n   *\n   * You can use it by providing a SSO domain. Typically you can extract this\n   * domain by asking users for their email address. If this domain is\n   * registered on the Auth instance the redirect will use that organization's\n   * currently active SSO Identity Provider for the login.\n   *\n   * If you have built an organization-specific login page, you can use the\n   * organization's SSO Identity Provider UUID directly instead.\n   *\n   * This API is experimental and availability is conditional on correct\n   * settings on the Auth service.\n   *\n   * @experimental\n   */\n  async signInWithSSO(params: SignInWithSSO): Promise<SSOResponse> {\n    try {\n      await this._removeSession()\n\n      return await _request(this.fetch, 'POST', `${this.url}/sso`, {\n        body: {\n          ...('providerId' in params ? { provider_id: params.providerId } : null),\n          ...('domain' in params ? { domain: params.domain } : null),\n          redirect_to: params.options?.redirectTo ?? undefined,\n          ...(params?.options?.captchaToken\n            ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\n            : null),\n          skip_http_redirect: true, // fetch does not handle redirects\n        },\n        headers: this.headers,\n        xform: _ssoResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Returns the session, refreshing it if necessary.\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n   */\n  async getSession(): Promise<\n    | {\n        data: {\n          session: Session\n        }\n        error: null\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: AuthError\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: null\n      }\n  > {\n    // make sure we've read the session from the url if there is one\n    // save to just await, as long we make sure _initialize() never throws\n    await this.initializePromise\n\n    let currentSession: Session | null = null\n\n    if (this.persistSession) {\n      const maybeSession = await getItemAsync(this.storage, this.storageKey)\n\n      if (maybeSession !== null) {\n        if (this._isValidSession(maybeSession)) {\n          currentSession = maybeSession\n        } else {\n          await this._removeSession()\n        }\n      }\n    } else {\n      currentSession = this.inMemorySession\n    }\n\n    if (!currentSession) {\n      return { data: { session: null }, error: null }\n    }\n\n    const hasExpired = currentSession.expires_at\n      ? currentSession.expires_at <= Date.now() / 1000\n      : false\n    if (!hasExpired) {\n      return { data: { session: currentSession }, error: null }\n    }\n\n    const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n    if (error) {\n      return { data: { session: null }, error }\n    }\n\n    return { data: { session }, error: null }\n  }\n\n  /**\n   * Gets the current user details if there is an existing session.\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n   */\n  async getUser(jwt?: string): Promise<UserResponse> {\n    try {\n      if (!jwt) {\n        const { data, error } = await this.getSession()\n        if (error) {\n          throw error\n        }\n\n        // Default to Authorization header if there is no existing session\n        jwt = data.session?.access_token ?? undefined\n      }\n\n      return await _request(this.fetch, 'GET', `${this.url}/user`, {\n        headers: this.headers,\n        jwt: jwt,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n  async updateUser(attributes: UserAttributes): Promise<UserResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        throw sessionError\n      }\n      if (!sessionData.session) {\n        throw new AuthSessionMissingError()\n      }\n      const session: Session = sessionData.session\n      const { data, error: userError } = await _request(this.fetch, 'PUT', `${this.url}/user`, {\n        headers: this.headers,\n        body: attributes,\n        jwt: session.access_token,\n        xform: _userResponse,\n      })\n      if (userError) throw userError\n      session.user = data.user as User\n      await this._saveSession(session)\n      this._notifyAllSubscribers('USER_UPDATED', session)\n\n      return { data: { user: session.user }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Decodes a JWT (without performing any validation).\n   */\n  private _decodeJWT(jwt: string): {\n    exp?: number\n    aal?: AuthenticatorAssuranceLevels | null\n    amr?: AMREntry[] | null\n  } {\n    return decodeJWTPayload(jwt)\n  }\n\n  /**\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\n   * @param currentSession The current session that minimally contains an access token and refresh token.\n   */\n  async setSession(currentSession: {\n    access_token: string\n    refresh_token: string\n  }): Promise<AuthResponse> {\n    try {\n      if (!currentSession.access_token || !currentSession.refresh_token) {\n        throw new AuthSessionMissingError()\n      }\n\n      const timeNow = Date.now() / 1000\n      let expiresAt = timeNow\n      let hasExpired = true\n      let session: Session | null = null\n      const payload = decodeJWTPayload(currentSession.access_token)\n      if (payload.exp) {\n        expiresAt = payload.exp\n        hasExpired = expiresAt <= timeNow\n      }\n\n      if (hasExpired) {\n        const { session: refreshedSession, error } = await this._callRefreshToken(\n          currentSession.refresh_token\n        )\n        if (error) {\n          return { data: { user: null, session: null }, error: error }\n        }\n\n        if (!refreshedSession) {\n          return { data: { user: null, session: null }, error: null }\n        }\n        session = refreshedSession\n      } else {\n        const { data, error } = await this.getUser(currentSession.access_token)\n        if (error) {\n          throw error\n        }\n        session = {\n          access_token: currentSession.access_token,\n          refresh_token: currentSession.refresh_token,\n          user: data.user,\n          token_type: 'bearer',\n          expires_in: expiresAt - timeNow,\n          expires_at: expiresAt,\n        }\n        await this._saveSession(session)\n      }\n\n      return { data: { user: session.user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Returns a new session, regardless of expiry status.\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n   * If the current session's refresh token is invalid, an error will be thrown.\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\n   */\n  async refreshSession(currentSession?: { refresh_token: string }): Promise<AuthResponse> {\n    try {\n      if (!currentSession) {\n        const { data, error } = await this.getSession()\n        if (error) {\n          throw error\n        }\n\n        currentSession = data.session ?? undefined\n      }\n\n      if (!currentSession?.refresh_token) {\n        throw new AuthSessionMissingError()\n      }\n\n      const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n      if (error) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      if (!session) {\n        return { data: { user: null, session: null }, error: null }\n      }\n\n      return { data: { user: session.user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Gets the session data from a URL string\n   */\n  private async _getSessionFromUrl(): Promise<\n    | {\n        data: { session: Session; redirectType: string | null }\n        error: null\n      }\n    | { data: { session: null; redirectType: null }; error: AuthError }\n  > {\n    try {\n      if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.')\n      if (!this._isImplicitGrantFlow()) {\n        throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.')\n      }\n\n      const error_description = getParameterByName('error_description')\n      if (error_description) {\n        const error_code = getParameterByName('error_code')\n        if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.')\n        const error = getParameterByName('error')\n        if (!error) throw new AuthImplicitGrantRedirectError('No error detected.')\n\n        throw new AuthImplicitGrantRedirectError(error_description, { error, code: error_code })\n      }\n\n      const provider_token = getParameterByName('provider_token')\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\n      const access_token = getParameterByName('access_token')\n      if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.')\n      const expires_in = getParameterByName('expires_in')\n      if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.')\n      const refresh_token = getParameterByName('refresh_token')\n      if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.')\n      const token_type = getParameterByName('token_type')\n      if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.')\n\n      const timeNow = Math.round(Date.now() / 1000)\n      const expires_at = timeNow + parseInt(expires_in)\n\n      const { data, error } = await this.getUser(access_token)\n      if (error) throw error\n      const user: User = data.user\n      const session: Session = {\n        provider_token,\n        provider_refresh_token,\n        access_token,\n        expires_in: parseInt(expires_in),\n        expires_at,\n        refresh_token,\n        token_type,\n        user,\n      }\n      const redirectType = getParameterByName('type')\n\n      // Remove tokens from URL\n      window.location.hash = ''\n\n      return { data: { session, redirectType }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, redirectType: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n   */\n  private _isImplicitGrantFlow(): boolean {\n    return (\n      isBrowser() &&\n      (Boolean(getParameterByName('access_token')) ||\n        Boolean(getParameterByName('error_description')))\n    )\n  }\n\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n   */\n  async signOut(): Promise<{ error: AuthError | null }> {\n    const { data, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { error: sessionError }\n    }\n    const accessToken = data.session?.access_token\n    if (accessToken) {\n      const { error } = await this.admin.signOut(accessToken)\n      if (error) {\n        // ignore 404s since user might not exist anymore\n        // ignore 401s since an invalid or expired JWT should sign out the current session\n        if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\n          return { error }\n        }\n      }\n    }\n    await this._removeSession()\n    this._notifyAllSubscribers('SIGNED_OUT', null)\n    return { error: null }\n  }\n\n  /**\n   * Receive a notification every time an auth event happens.\n   * @param callback A callback function to be invoked when an auth event happens.\n   */\n  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): {\n    data: { subscription: Subscription }\n  } {\n    const id: string = uuid()\n    const subscription: Subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id)\n      },\n    }\n\n    this.stateChangeEmitters.set(id, subscription)\n\n    return { data: { subscription } }\n  }\n\n  /**\n   * Sends a password reset request to an email address.\n   * @param email The email address of the user.\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n   */\n  async resetPasswordForEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<\n    | {\n        data: {}\n        error: null\n      }\n    | { data: null; error: AuthError }\n  > {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/recover`, {\n        body: { email, gotrue_meta_security: { captcha_token: options.captchaToken } },\n        headers: this.headers,\n        redirectTo: options.redirectTo,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  private async _refreshAccessToken(refreshToken: string): Promise<AuthResponse> {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n        body: { refresh_token: refreshToken },\n        headers: this.headers,\n        xform: _sessionResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n      throw error\n    }\n  }\n\n  private _isValidSession(maybeSession: unknown): maybeSession is Session {\n    const isValidSession =\n      typeof maybeSession === 'object' &&\n      maybeSession !== null &&\n      'access_token' in maybeSession &&\n      'refresh_token' in maybeSession &&\n      'expires_at' in maybeSession\n\n    return isValidSession\n  }\n\n  private _handleProviderSignIn(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    } = {}\n  ) {\n    const url: string = this._getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams,\n    })\n    // try to open on the browser\n    if (isBrowser()) {\n      window.location.href = url\n    }\n    return { data: { provider, url }, error: null }\n  }\n\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  private async _recoverAndRefresh() {\n    try {\n      const currentSession = await getItemAsync(this.storage, this.storageKey)\n      if (!this._isValidSession(currentSession)) {\n        if (currentSession !== null) {\n          await this._removeSession()\n        }\n\n        return\n      }\n\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if ((currentSession.expires_at ?? Infinity) < timeNow + EXPIRY_MARGIN) {\n        if (this.autoRefreshToken && currentSession.refresh_token) {\n          this.networkRetries++\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\n          if (error) {\n            console.log(error.message)\n            if (\n              error instanceof AuthRetryableFetchError &&\n              this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\n            ) {\n              if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n              this.refreshTokenTimer = setTimeout(\n                () => this._recoverAndRefresh(),\n                NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100 // exponential backoff\n              )\n              return\n            }\n            await this._removeSession()\n          }\n          this.networkRetries = 0\n        } else {\n          await this._removeSession()\n        }\n      } else {\n        if (this.persistSession) {\n          await this._saveSession(currentSession)\n        }\n        this._notifyAllSubscribers('SIGNED_IN', currentSession)\n      }\n    } catch (err) {\n      console.error(err)\n      return\n    }\n  }\n\n  private async _callRefreshToken(refreshToken: string): Promise<CallRefreshTokenResult> {\n    // refreshing is already in progress\n    if (this.refreshingDeferred) {\n      return this.refreshingDeferred.promise\n    }\n\n    try {\n      this.refreshingDeferred = new Deferred<CallRefreshTokenResult>()\n\n      if (!refreshToken) {\n        throw new AuthSessionMissingError()\n      }\n      const { data, error } = await this._refreshAccessToken(refreshToken)\n      if (error) throw error\n      if (!data.session) throw new AuthSessionMissingError()\n\n      await this._saveSession(data.session)\n      this._notifyAllSubscribers('TOKEN_REFRESHED', data.session)\n\n      const result = { session: data.session, error: null }\n\n      this.refreshingDeferred.resolve(result)\n\n      return result\n    } catch (error) {\n      if (isAuthError(error)) {\n        const result = { session: null, error }\n\n        this.refreshingDeferred?.resolve(result)\n\n        return result\n      }\n\n      this.refreshingDeferred?.reject(error)\n      throw error\n    } finally {\n      this.refreshingDeferred = null\n    }\n  }\n\n  private _notifyAllSubscribers(event: AuthChangeEvent, session: Session | null) {\n    this.stateChangeEmitters.forEach((x) => x.callback(event, session))\n  }\n\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  private async _saveSession(session: Session) {\n    if (!this.persistSession) {\n      this.inMemorySession = session\n    }\n\n    const expiresAt = session.expires_at\n    if (expiresAt) {\n      const timeNow = Math.round(Date.now() / 1000)\n      const expiresIn = expiresAt - timeNow\n      const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000)\n    }\n\n    if (this.persistSession && session.expires_at) {\n      await this._persistSession(session)\n    }\n  }\n\n  private _persistSession(currentSession: Session) {\n    return setItemAsync(this.storage, this.storageKey, currentSession)\n  }\n\n  private async _removeSession() {\n    if (this.persistSession) {\n      await removeItemAsync(this.storage, this.storageKey)\n    } else {\n      this.inMemorySession = null\n    }\n\n    if (this.refreshTokenTimer) {\n      clearTimeout(this.refreshTokenTimer)\n    }\n  }\n\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds.\n   * @param session The current session.\n   */\n  private _startAutoRefreshToken(value: number) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n    if (value <= 0 || !this.autoRefreshToken) return\n\n    this.refreshTokenTimer = setTimeout(async () => {\n      this.networkRetries++\n      const {\n        data: { session },\n        error: sessionError,\n      } = await this.getSession()\n      if (!sessionError && session) {\n        const { error } = await this._callRefreshToken(session.refresh_token)\n        if (!error) this.networkRetries = 0\n        if (\n          error instanceof AuthRetryableFetchError &&\n          this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\n        )\n          this._startAutoRefreshToken(NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100) // exponential backoff\n      }\n    }, value)\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref()\n  }\n\n  private _handleVisibilityChange() {\n    if (!isBrowser() || !window?.addEventListener) {\n      return false\n    }\n\n    try {\n      window?.addEventListener('visibilitychange', async () => {\n        if (document.visibilityState === 'visible') {\n          await this.initializePromise\n          await this._recoverAndRefresh()\n        }\n      })\n    } catch (error) {\n      console.error('_handleVisibilityChange', error)\n    }\n  }\n\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n   */\n  private _getUrlForProvider(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    }\n  ) {\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\n    if (options?.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\n    }\n    if (options?.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\n    }\n    if (options?.queryParams) {\n      const query = new URLSearchParams(options.queryParams)\n      urlParams.push(query.toString())\n    }\n    return `${this.url}/authorize?${urlParams.join('&')}`\n  }\n\n  private async _unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      return await _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n        headers: this.headers,\n        jwt: sessionData?.session?.access_token,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Enrolls a factor\n   * @param friendlyName Human readable name assigned to a device\n   * @param factorType device which we're validating against. Can only be TOTP for now.\n   * @param issuer domain which the user is enrolling with\n   */\n  private async _enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/factors`, {\n        body: {\n          friendly_name: params.friendlyName,\n          factor_type: params.factorType,\n          issuer: params.issuer,\n        },\n        headers: this.headers,\n        jwt: sessionData?.session?.access_token,\n      })\n\n      if (error) {\n        return { data: null, error }\n      }\n\n      if (data?.totp?.qr_code) {\n        data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`\n      }\n\n      return { data, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Validates a device as part of the enrollment step.\n   * @param factorId System assigned identifier for authenticator device as returned by enroll\n   * @param code Code Generated by an authenticator device\n   */\n  private async _verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      const { data, error } = await _request(\n        this.fetch,\n        'POST',\n        `${this.url}/factors/${params.factorId}/verify`,\n        {\n          body: { code: params.code, challenge_id: params.challengeId },\n          headers: this.headers,\n          jwt: sessionData?.session?.access_token,\n        }\n      )\n      if (error) {\n        return { data: null, error }\n      }\n\n      await this._saveSession({\n        expires_at: Math.round(Date.now() / 1000) + data.expires_in,\n        ...data,\n      })\n      this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data)\n\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Creates a challenge which a user can verify against\n   * @param factorId System assigned identifier for authenticator device as returned by enroll\n   */\n  private async _challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      return await _request(\n        this.fetch,\n        'POST',\n        `${this.url}/factors/${params.factorId}/challenge`,\n        {\n          headers: this.headers,\n          jwt: sessionData?.session?.access_token,\n        }\n      )\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Creates a challenge and immediately verifies it\n   * @param factorId System assigned identifier for authenticator device as returned by enroll\n   * @param code Code Generated by an authenticator device\n   */\n  private async _challengeAndVerify(\n    params: MFAChallengeAndVerifyParams\n  ): Promise<AuthMFAVerifyResponse> {\n    const { data: challengeData, error: challengeError } = await this._challenge({\n      factorId: params.factorId,\n    })\n    if (challengeError) {\n      return { data: null, error: challengeError }\n    }\n    return await this._verify({\n      factorId: params.factorId,\n      challengeId: challengeData.id,\n      code: params.code,\n    })\n  }\n\n  /**\n   * Displays all devices for a given user\n   */\n  private async _listFactors(): Promise<AuthMFAListFactorsResponse> {\n    const {\n      data: { user },\n      error: userError,\n    } = await this.getUser()\n    if (userError) {\n      return { data: null, error: userError }\n    }\n\n    const factors = user?.factors || []\n    const totp = factors.filter(\n      (factor) => factor.factor_type === 'totp' && factor.status === 'verified'\n    )\n\n    return {\n      data: {\n        all: factors,\n        totp,\n      },\n      error: null,\n    }\n  }\n\n  /**\n   * Gets the current and next authenticator assurance level (AAL)\n   * and the current authentication methods for the session (AMR)\n   */\n  private async _getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse> {\n    const {\n      data: { session },\n      error: sessionError,\n    } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n    if (!session) {\n      return {\n        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n        error: null,\n      }\n    }\n\n    const payload = this._decodeJWT(session.access_token)\n\n    let currentLevel: AuthenticatorAssuranceLevels | null = null\n\n    if (payload.aal) {\n      currentLevel = payload.aal\n    }\n\n    let nextLevel: AuthenticatorAssuranceLevels | null = currentLevel\n\n    const verifiedFactors =\n      session.user.factors?.filter((factor: Factor) => factor.status === 'verified') ?? []\n\n    if (verifiedFactors.length > 0) {\n      nextLevel = 'aal2'\n    }\n\n    const currentAuthenticationMethods = payload.amr || []\n\n    return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}